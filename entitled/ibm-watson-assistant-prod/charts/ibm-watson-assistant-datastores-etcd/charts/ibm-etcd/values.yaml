# Default values for etcd.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

global:
  image:
    repository: ""
    pullSecret: ""
  # global.deploymentType Valid values are Development or Production. A Production deployment is scaled up i.e. a higher number of replicas.
  deploymentType: "Development"

  # global.podAntiAffinity Valid values are Default, Enable or Disable
  podAntiAffinity: "Default"

  sch:
    enabled: true

# if true, don't delete the datastore objects during a helm delete
keep: true 

# nameOverride - Specifies the suffix in the kubernetes names after the {{ .Release.name }}. The default suffix ibm-wcd-etcd is used if the override is emptys.
nameOverride: ""

replicaCount: 3

image:
  repository: opencontent-etcd-3
  tag: 1.1.1
  pullPolicy: Always

certgen:
  image:
    repository: opencontent-icp-cert-gen-1
    tag: 1.1.1
    pullPolicy: IfNotPresent

resources:
  requests:
    cpu: 1
    memory: 2Gi
  limits:
    # cpu limits removed for WA ICP deployments
    memory: 4Gi

maxEtcdThreads: 2

auth:
  enabled: true
  existingRootSecret: ""
  

rbac:
  create: true
  existingServiceAccount:

persistence:
  enabled: true

  # useDynamicProvisioning - if enabled the dataPVC.storageClassName volumes will be dynamicaly created (if the storage class can be created automatically).
  #  If disabled either dataPVC.selectot.label should be specify and then the PVC will bound to precreated PV based on labels or dataPVC.storageClassName should be empty and then cluster admin has to bound the PVC to existing PV manually
  useDynamicProvisioning: true

dataPVC:
  accessMode: ReadWriteOnce
  # name - name (prefix) of the created PVC
  name: data

  # storageClassName - specify the storageClassName you want to use
  # if you don't specify a storageClassName it will use the storage class selected (default) storage class if it exists. In there is no default sotage class, and storageClassName you will have to bound PVC to PV manually
  storageClassName:

  # selector - if you not using dynamic provisioning, you can use selectors to refine the binding process. You cannot specify a selector if your using dynamic provisioning.
  selector:
    # label - label that the PV should have to be boundable to created PVCs
    label: ""
    # value - value of the label that the PV should have to be boundable to created PVCs
    value: ""

  size: 1Gi

tls:
  enabled: true
  existingTlsSecret: ""

# Readiness probe
readinessProbe:
  initialDelaySeconds: 15
  timeoutSeconds: 1
  failureThreshold: 5
  periodSeconds: 10
  successThreshold: 1

# Liveness probe
livenessProbe:
  initialDelaySeconds: 15
  timeoutSeconds: 5
  failureThreshold: 5
  periodSeconds: 10
  successThreshold: 1

# clusterDomain - the suffix of all the cluster DNS names like service_name.service_namespace.svc.cluster.local.  Supports templated values like "{{ .Values.global.clusterDomain }}"
clusterDomain: "cluster.local"

podDisruptionBudget: {}
