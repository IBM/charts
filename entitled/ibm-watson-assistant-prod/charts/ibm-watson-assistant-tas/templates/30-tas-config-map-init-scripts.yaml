apiVersion: v1
kind: ConfigMap
metadata:
  name: "{{ .Release.Name }}-tas-init-scripts"
  labels:
    service:   "conversation"
    component: "tas"
    slot:      "{{ .Release.Name }}"
    app: "ibm-watson-assistant-prod-1.3.0"
    chart: "ibm-watson-assistant"
    heritage: "{{ .Release.Service }}"
    release: "{{ .Release.Name }}"
data:
  mongodb_loaded.sh: |
    #!/bin/bash
    # Assumes CLU secret is mounted to /opt/watson/dynconfig/
    
    if [ ${DEBUG} ] ; then
      set -x
    fi
    
    mongo_url=`cat /opt/watson/dynconfig/mongodb_connection_string`
    cp /opt/watson/dynconfig/mongodb_certificate /tmp/ca.pem
    echo "Step Testing connection and continue only after mongo is available"
    while true; do
      mongo --ssl --sslAllowInvalidCertificates --sslCAFile=/tmp/ca.pem --authenticationDatabase=admin $mongo_url --eval "db.hostInfo()" && break;
      sleep 5
    done
    while true; do
      is_ready=$(mongo --quiet --ssl --sslAllowInvalidCertificates --sslCAFile=/tmp/ca.pem --authenticationDatabase=admin $mongo_url --eval "rs.slaveOk();printjson(db.getSiblingDB('nlclassifier').getCollection('status').find({data_status:\"ready\"}).toArray()[0]['data_status'])" | tail -1)
      if [ '"ready"' == "$is_ready" ] ; then
        break;
      fi
      echo "Mongo collections for clu are not ready."; sleep 5
    done
    
    wv_conversation_count=0
    wv_conversation_mtl_count=0
    wv_openentities_linear_count=0
    
    # Printing collections:
    while true; do
        wv_conversation_count=$(       mongo --ssl --sslAllowInvalidCertificates --sslCAFile=/tmp/ca.pem --authenticationDatabase=admin "$mongo_url" --eval "rs.slaveOk();printjson(db.getSiblingDB('nlclassifier').wv_conversation.count())"        --quiet | tail -1)
        wv_conversation_mtl_count=$(   mongo --ssl --sslAllowInvalidCertificates --sslCAFile=/tmp/ca.pem --authenticationDatabase=admin "$mongo_url" --eval "rs.slaveOk();printjson(db.getSiblingDB('nlclassifier').wv_conversation_mtl.count())"    --quiet | tail -1)
        wv_openentities_linear_count=$(mongo --ssl --sslAllowInvalidCertificates --sslCAFile=/tmp/ca.pem --authenticationDatabase=admin "$mongo_url" --eval "rs.slaveOk();printjson(db.getSiblingDB('nlclassifier').wv_openentities_linear.count())" --quiet | tail -1)
      
        if [ $wv_conversation_count -gt 0 ] && [ $wv_conversation_mtl_count -gt 0 ] && [ $wv_openentities_linear_count -gt 0 ] ; then
            break;
        fi
        sleep 10
    done
    
    echo "We checked that mongo collections for clu are loaded! Done."
    echo ""
    echo "wv_conversation: $wv_conversation_count"
    echo "wv_conversation_mtl: $wv_conversation_mtl_count"
    echo "wv_openentities_linear: $wv_openentities_linear_count"
    echo "Done."
  
  cos_ready.sh: |
    #!/bin/sh
    # Expects the env variable:
    #    "TAS_SERVICE_NAME" - the name of the TAS in ETCD (litelinks name).
    # Assumes etcd secret is mounted to /etc/secrets/etcd
    
     if [ ${DEBUG} ] ; then
      set -x
    fi
    
    set -e
    # Step 1 try to read the COS (objectore) string from ETCD
    # configure etcdctl
    export ETCDCTL_API ETCDCTL_ENDPOINTS ETCDCTL_USER ETCDCTL_CACERT ETCDCTL_DIAL_TIMEOUT ETCDCTL_COMMAND_TIMEOUT
    # use some defaults from the secrets mount unless already specified
    ETCDCTL_API=${ETCDCTL_API:-3}
    ETCDCTL_ENDPOINTS=${ETCDCTL_ENDPOINTS:-$(</etc/secrets/etcd/etcd_connection jq -r '.endpoints')}
    ETCDCTL_USER=${ETCDCTL_USER:-$(</etc/secrets/etcd/etcd_connection jq -r '.userid + ":" + .password')}
    ETCDCTL_CACERT=${ETCDCTL_CACERT:-'/etc/secrets/etcd/etcd_certificate'}
    ETCDCTL_DIAL_TIMEOUT=${ETCDCTL_DIAL_TIMEOUT:-10s}
    ETCDCTL_COMMAND_TIMEOUT=${ETCDCTL_COMMAND_TIMEOUT:-10s}
    
    ETCD_CHROOT=${ETCD_CHROOT:-$(</etc/secrets/etcd/etcd_connection jq -r '.root_prefix')}
    
    echo "Trying to extract the objectstore (COS/Minio) connection string from ETCD"
    objectstoreString=""
    while [ -z "${objectstoreString}" ] ; do
      echo "Running: etcdctl get \"${ETCD_CHROOT}/shared/config/objectstore\""
      OBJECTSTORE_GLOBAL=$(etcdctl get -w json "${ETCD_CHROOT}/shared/config/objectstore" | jq -r ' if has("kvs") then .kvs[0].value | @base64d else "" end' )
      [ -n ${OBJECTSTORE_GLOBAL} ] && objectstoreString="${OBJECTSTORE_GLOBAL}"
      
      echo "Running: etcdctl get \"${ETCD_CHROOT}/tas-runtime/${TAS_SERVICE_NAME}/config/objectstore\""
      OBJECTSTORE_REALM_SPECIFIC=$(etcdctl get -w json "${ETCD_CHROOT}/tas-runtime/${TAS_SERVICE_NAME}/config/objectstore"  | jq -r ' if has("kvs") then .kvs[0].value | @base64d else "" end' )
      [ -n ${OBJECTSTORE_REALM_SPECIFIC} ] && objectstoreString="${OBJECTSTORE_REALM_SPECIFIC}"
      
      if [ -z "${objectstoreString}" ] ; then 
         echo "Could not extract any of the entries  or all of them are empty. Sleeping 10 sec before retrying."
         sleep 10
      fi
    done
    
    echo "Parsing the object store"
    KIND=$(echo "${objectstoreString}" | sed 's/,.*//')
    if [ "${KIND}" = "swift" ] ; then
      echo "Detected SLOC (swift) type. Assuming the service is working"
      exit 0
    fi
    
    if [ "${KIND}" != "s3" ] ; then
      echo "ERROR: Invalid unsupported objectore type (${KIND}), expecting s3"
      exit 1
    fi
    ENDPOINT=$(     echo "${objectstoreString}" | tr "," $'\n' | grep "^endpoint="     | sed 's/^endpoint=//')
    ACCESS_KEY=$(   echo "${objectstoreString}" | tr "," $'\n' | grep "^accesskey="    | sed 's/^accesskey=//')
    SECRET_KEY=$(   echo "${objectstoreString}" | tr "," $'\n' | grep "^secretkey="    | sed 's/^secretkey=//')
    BUCKET_SUFFIX=$(echo "${objectstoreString}" | tr "," $'\n' | grep "^bucketsuffix=" | sed 's/^bucketsuffix=//')
    
    # Add schema if missing
    if [ "${ENDPOINT:0:7}" != "http://" -a "${ENDPOINT:0:8}" != "https://" ] ; then
      ENDPOINT="https://${ENDPOINT}"
    fi 
    
    # Creating link to file with certificate to COS
    mkdir -p /home/app/.mc/certs/CAs/
    if [ -e "/etc/secrets/cos/ca.crt" ] ; then
      ln -s /etc/secrets/cos/ca.crt /home/app/.mc/certs/CAs/ca.crt
    fi
    
    echo "Trying to connect into COS/Minio"
    
    RETRY_MC_CONFIG=true
    while ${RETRY_MC_CONFIG} ; do
      echo "Running: mc config host add test \"${ENDPOINT}\" \"\${ACCESS_KEY}\" \"\${SECRET_KEY}\" S3v4"
      if mc config host add test "${ENDPOINT}" "${ACCESS_KEY}" "${SECRET_KEY}" S3v4 ; then
        RETRY_MC_CONFIG=false
      else
        echo "Error: mc configuration failed. Will retry in 10 sec."
        sleep 10
      fi
    done
    
    while true ; do
      echo "Running: mc ls test/"
      if mc ls test/ ; then
        echo "Successfully connected to COS/Minio"
        exit 0
      fi
      echo "Connection to COS/Minio errored, will retry in 10 seconds"
      sleep 10
    done
  
  etcd_running.sh: |
    #!/bin/sh
    # Checks if etcd is running and password authorization is enabled
    #   and key LL_FULL_SERVICE_NAME is created (i.e., configuration is written to etcd)
    # Assumes etcd secret is mounted to /etc/secrets/etcd
    #
    # Required container with etcdctl and jq commands (e.g., conan-tools)
     if [ ${DEBUG} ] ; then
      set -x
    fi
    
    set -e
    
    echo "Checking if ETCD is up and running and authorization is enabled"
    
    # configure etcdctl - use some defaults from the secrets mount unless already specified (as env vars)
    export ETCDCTL_API ETCDCTL_ENDPOINTS ETCDCTL_USER ETCDCTL_CACERT ETCDCTL_DIAL_TIMEOUT ETCDCTL_COMMAND_TIMEOUT
    ETCDCTL_API=${ETCDCTL_API:-3}
    ETCDCTL_ENDPOINTS=${ETCDCTL_ENDPOINTS:-$(</etc/secrets/etcd/etcd_connection jq -r '.endpoints')}
    ETCDCTL_USER=${ETCDCTL_USER:-$(</etc/secrets/etcd/etcd_connection jq -r '.userid + ":" + .password')}
    ETCDCTL_CACERT=${ETCDCTL_CACERT:-'/etc/secrets/etcd/etcd_certificate'}
    ETCDCTL_DIAL_TIMEOUT=${ETCDCTL_DIAL_TIMEOUT:-10s}
    ETCDCTL_COMMAND_TIMEOUT=${ETCDCTL_COMMAND_TIMEOUT:-10s}
    
    ETCD_CHROOT=${ETCD_CHROOT:-$(</etc/secrets/etcd/etcd_connection jq -r '.root_prefix')}
    
    
    while true ; do
      echo "etcdctl endpoint health"
      etcdctl endpoint health && break
      echo "  command failed. Waiting 5 sec before next retry"
      sleep 5
    done
    echo ""
    echo "ETCD seems to be running. Checking if authorization is enabled"
    while true ; do
      echo ""
      echo "Running (with correct credentials): etcdctl put /test \"test\""
      if etcdctl put /test "test"; then
        echo "Running (with wrong credentials): etcdctl put /test \"test_wrong_creds\""
        if ETCDCTL_USER=${ETCDCTL_USER/:/:xxx} etcdctl put /test "test_wrong_creds"; then
          echo "  It seems that AUTHORIZATION is not enabled. The write command succeeded with invalid password. Retry in 5 sec"
          sleep 5
        else
          # Above command failed as expected. --> we are happy
          echo "  write command failed as expected"
          break
        fi
      else 
        echo "  It seems test put failed (etcd is not working correctly). Retry in 5 sec"
        sleep 5
      fi
    done
    
    echo
    echo "It seems ETCD is ready. Check if configuration entries are written."
    while true ; do
      echo "etcdctl get \"${ETCD_CHROOT}/${LL_FULL_SERVICE_NAME}\""
      if [ -n "$(etcdctl get "${ETCD_CHROOT}/${LL_FULL_SERVICE_NAME}" )" ] ; then
        echo "  test passed"
        etcdctl get "${ETCD_CHROOT}/${LL_FULL_SERVICE_NAME}"
        break;
      fi
      echo "entry not created. Retry in 5 sec"
      sleep 5
    done
    echo "ETCD is ready and configuration is stored there. Going to start microservice."
